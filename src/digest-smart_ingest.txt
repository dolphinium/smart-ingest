Directory structure:
└── smart_ingest/
    ├── README.md
    ├── requirements.txt
    ├── .env.example
    └── src/
        ├── config.py
        ├── main.py
        ├── __pycache__/
        └── core/
            ├── __init__.py
            ├── directory_analyzer.py
            ├── gemini_client.py
            ├── repository_handler.py
            └── __pycache__/

================================================
File: README.md
================================================
# Smart Ingest

[![Python Version](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)

**Smart Ingest** is a tool designed to intelligently prepare code repositories or local directories for analysis by Large Language Models (LLMs). It enhances the functionality of the `gitingest` library by incorporating Google Gemini to automatically generate relevant `.gitignore`-style exclude patterns. This helps ensure that only meaningful code is included in the output digest, filtering out dependencies, build artifacts, configuration files, and other noise.

## Core Features

*   **Intelligent Exclusions:** Leverages Google Gemini (via `google-generativeai`) to analyze the directory structure and suggest contextually relevant files and directories to exclude (e.g., `node_modules`, `venv`, `__pycache__`, build outputs, IDE configs).
*   **Source Flexibility:** Ingests code from both local directories and remote Git repositories (HTTP/HTTPS/SSH).
*   **Customizable Filtering:** Allows users to provide additional custom include and exclude patterns alongside the automatically generated ones.
*   **`gitingest` Integration:** Builds upon the `gitingest` library for the core code collection and formatting process.
*   **Configuration:** Configurable via environment variables (`.env` file) and command-line arguments (API keys, Gemini model, analysis depth, retries).
*   **Dry Run Mode:** Preview the directory structure analysis and the final set of exclude patterns without actually performing the ingestion.
*   **Directory Tree View:** Option to display the analyzed directory tree that is sent to Gemini for pattern generation.

## How it Works

1.  **Source Preparation:** Clones the repository into a temporary directory if a URL is provided, or resolves the path if a local directory is given.
2.  **Directory Analysis (Optional):** If automatic exclusion is enabled (default), it analyzes the directory structure up to a specified depth (`--max-depth`).
3.  **Gemini Pattern Generation (Optional):** Sends the analyzed directory tree structure to the configured Google Gemini model. A specialized prompt guides Gemini to identify common files/directories (present *only* in the provided structure) that should typically be excluded for LLM analysis and return them as `.gitignore`-style patterns.
4.  **Pattern Consolidation:** Combines automatically generated patterns (if any) with user-provided exclude patterns (`--exclude-pattern`). User-provided include patterns (`--include-pattern`) take precedence.
5.  **Ingestion:** Executes `gitingest` with the source path and the final consolidated set of include/exclude patterns.
6.  **Output:** Writes the collected code content into a single output file (default: `digest-<repo_name>.txt` or `digest-<dir_name>.txt`).
7.  **Cleanup:** Removes the temporary directory if a repository was cloned.

## Requirements

*   Python 3.7+
*   Git (must be installed and in your system's PATH if cloning repositories)
*   Dependencies listed in `requirements.txt`:
    *   `gitingest`
    *   `google-generativeai`
    *   `python-dotenv`
    *   `pydantic`

## Installation

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/dolphinium/smart-ingest
    cd smart_ingest
    ```
2.  **Create and activate a virtual environment (I recommended conda):**
    ```bash
    conda create -n smart-ingest python=3.10 -y 
    conda activate smart-ingest
    ```
3.  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

## Configuration

Smart Ingest uses environment variables for configuration, primarily for the Gemini API.

1.  **Copy the example environment file:**
    ```bash
    cp .env.example .env
    ```
2.  **Edit the `.env` file:**
    ```dotenv
    # .env
    GEMINI_API_KEY=your_google_generative_ai_api_key_here # REQUIRED for automatic exclusion
    GEMINI_MODEL=gemini-2.0-flash # Optional: Defaults to 'gemini-2.0-flash' if not set
    ```
    *   Replace `your_google_generative_ai_api_key_here` with your actual API key obtained from [Google AI Studio](https://aistudio.google.com/app/apikey).
    *   You can optionally change the `GEMINI_MODEL` to another compatible model.

*Note: The `--api-key` and `--gemini-model` command-line arguments override these environment variables.*

**Important:** If you don't provide a `GEMINI_API_KEY` (either via `.env` or `--api-key`), the automatic exclude pattern generation feature will be disabled, even if `--no-auto-exclude` is not set.

## Usage

Run the script from the command line using `python main.py`.

```bash
python main.py <source> [options]
```

**Examples:**

1.  **Ingest a local directory with automatic exclusions:**
    ```bash
    python main.py /path/to/your/project
    ```
    *(Requires `GEMINI_API_KEY` to be set in `.env` or passed via `--api-key`)*

2.  **Ingest a remote Git repository (main branch) with automatic exclusions:**
    ```bash
    python main.py https://github.com/user/repo.git
    ```
    *(Requires `GEMINI_API_KEY`)*

3.  **Ingest a specific branch of a remote repository:**
    ```bash
    python main.py https://github.com/user/repo.git --branch develop
    ```

4.  **Ingest with custom exclude patterns (disables automatic generation):**
    ```bash
    python main.py /path/to/project --no-auto-exclude -e "docs/" -e "*.log"
    ```

5.  **Ingest with automatic exclusions *and* additional custom patterns:**
    ```bash
    python main.py /path/to/project -e "config.yaml" -e "temp_files/"
    ```
    *(Gemini will suggest patterns, and `config.yaml`, `temp_files/` will also be excluded)*

6.  **Ingest only specific file types using include patterns:**
    ```bash
    python main.py /path/to/project --no-auto-exclude -i "*.py" -i "*.js"
    ```
    *(Note: Include patterns override excludes. Use with caution, may include unwanted files if automatic exclusion is off)*

7.  **Specify a custom output file:**
    ```bash
    python main.py /path/to/project -o my_project_digest.txt
    ```

8.  **Dry run: See the generated exclude patterns without ingesting:**
    ```bash
    python main.py /path/to/project --dry-run
    ```

9.  **Dry run and show the directory tree sent to Gemini:**
    ```bash
    python main.py /path/to/project --dry-run --show-tree
    ```

## Command-Line Options

```
usage: main.py [-h] [--output OUTPUT] [--max-size MAX_SIZE] [--exclude-pattern EXCLUDE_PATTERN] [--include-pattern INCLUDE_PATTERN] [--branch BRANCH] [--api-key API_KEY]
               [--gemini-model GEMINI_MODEL] [--no-auto-exclude] [--max-depth MAX_DEPTH] [--dry-run] [--show-tree] [--retries RETRIES]
               source

Enhanced GitIngest with Gemini-powered automatic exclude pattern generation

positional arguments:
  source                Source directory or repository URL

options:
  -h, --help            show this help message and exit
  --output OUTPUT, -o OUTPUT
                        Output file path (default: digest-<name>.txt)
  --max-size MAX_SIZE, -s MAX_SIZE
                        Maximum file size to process in bytes (default: 10MB)
  --exclude-pattern EXCLUDE_PATTERN, -e EXCLUDE_PATTERN
                        Additional patterns to exclude (can be specified multiple times)
  --include-pattern INCLUDE_PATTERN, -i INCLUDE_PATTERN
                        Patterns to include (overrides excludes, can be specified multiple times)
  --branch BRANCH, -b BRANCH
                        Branch to clone and ingest if source is a URL
  --api-key API_KEY     Gemini API key (overrides GEMINI_API_KEY environment variable)
  --gemini-model GEMINI_MODEL
                        Gemini model for pattern generation (overrides GEMINI_MODEL environment variable)
  --no-auto-exclude     Disable automatic exclude pattern generation via Gemini
  --max-depth MAX_DEPTH
                        Maximum directory traversal depth for analysis tree (default: 8)
  --dry-run             Generate and show exclude patterns without performing ingestion
  --show-tree           Show the directory tree used for analysis
  --retries RETRIES     Number of Gemini API call retries (default: 3)
```




================================================
File: requirements.txt
================================================
gitingest
google-generativeai
python-dotenv
pydantic



================================================
File: .env.example
================================================
GEMINI_API_KEY=your_api_key_here
GEMINI_MODEL=gemini-2.0-flash


================================================
File: src/config.py
================================================
import os
from dataclasses import dataclass
from typing import Optional

from dotenv import load_dotenv


@dataclass
class Config:
    """Configuration for Smart Ingest."""
    
    api_key: Optional[str]
    gemini_model: str
    max_depth: int
    retries: int


def load_config(args) -> Config:
    """Load configuration from environment and arguments."""
    load_dotenv()
    
    api_key = args.api_key or os.getenv("GEMINI_API_KEY")
    default_model = os.getenv("GEMINI_MODEL", "gemini-2.0-flash")
    
    if not args.no_auto_exclude and not api_key:
        print("Warning: --no-auto-exclude not set, but no Gemini API key found. Disabling automatic excludes.")
    
    return Config(
        api_key=api_key,
        gemini_model=args.gemini_model or default_model,
        max_depth=args.max_depth,
        retries=args.retries
    )


================================================
File: src/main.py
================================================
"""Enhanced GitIngest with Gemini-powered automatic exclude pattern generation."""

import argparse
import asyncio
import os
import sys
from pathlib import Path
from typing import Optional

from gitingest import ingest_async

from core.directory_analyzer import DirectoryAnalyzer
from core.gemini_client import GeminiExcludePatternGenerator
from core.repository_handler import RepositoryHandler
from config import Config, load_config


class SmartIngestApp:
    """Main application class for Smart Ingest."""
    
    def __init__(self, config: Config):
        self.config = config
        self.exclude_patterns: set[str] = set()
        self.repo_handler = RepositoryHandler()
        self.analyzer = DirectoryAnalyzer(max_depth=config.max_depth)
        
        if config.api_key:
            self.gemini_client = GeminiExcludePatternGenerator(
                api_key=config.api_key,
                model_name=config.gemini_model,
                retries=config.retries
            )
        else:
            self.gemini_client = None
    
    async def run(self, args: argparse.Namespace) -> None:
        """Main execution flow."""
        # Determine if source is URL or local path
        source = args.source
        is_url = self._is_repository_url(source)
        
        # Prepare local source path
        local_source_path, temp_dir = await self._prepare_source(source, is_url, args.branch)
        
        try:
            # Generate exclude patterns
            self.exclude_patterns = await self._generate_exclude_patterns(
                local_source_path, args, is_url
            )
            
            # Dry run or full execution
            if args.dry_run:
                print("\nDry run requested. Exiting without performing ingestion.")
                return
            
            # Execute GitIngest
            await self._execute_gitingest(local_source_path, args, is_url)
            
        finally:
            # Cleanup
            if temp_dir:
                print(f"Cleaning up temporary directory: {temp_dir.name}")
                temp_dir.cleanup()
    
    @staticmethod
    def _is_repository_url(source: str) -> bool:
        """Check if source is a repository URL."""
        return source.startswith(("http://", "https://", "git@"))
    
    async def _prepare_source(
        self, 
        source: str, 
        is_url: bool, 
        branch: Optional[str]
    ) -> tuple[str, Optional[object]]:
        """Prepare local source path and handle temporary directory if needed."""
        if is_url:
            temp_dir = self.repo_handler.create_temp_directory()
            local_path = temp_dir.name
            
            if not await self.repo_handler.clone_repo(source, local_path, branch):
                sys.exit(1)
                
            return local_path, temp_dir
        else:
            local_path = str(Path(source).resolve())
            if not Path(local_path).exists():
                print(f"Error: Local source path does not exist: {local_path}", file=sys.stderr)
                sys.exit(1)
            return local_path, None
    
    async def _generate_exclude_patterns(
        self, 
        local_source_path: str, 
        args: argparse.Namespace,
        is_url: bool
    ) -> set[str]:
        """Generate and combine exclude patterns."""
        patterns = set(args.exclude_pattern)
        
        if not args.no_auto_exclude and self.gemini_client and Path(local_source_path).is_dir():
            auto_patterns = await self._generate_auto_exclude_patterns(local_source_path, args)
            patterns.update(auto_patterns)
        
        self._display_patterns(patterns)
        return patterns
    
    async def _generate_auto_exclude_patterns(
        self, 
        local_source_path: str, 
        args: argparse.Namespace
    ) -> set[str]:
        """Generate automatic exclude patterns using Gemini."""
        print(f"Analyzing directory structure: {local_source_path}")
        
        directory_tree = self.analyzer.create_directory_tree(local_source_path)
        
        if args.show_tree:
            print("\n--- Directory Tree ---")
            print(directory_tree)
            print("--- End Tree ---\n")
        
        print(f"Generating intelligent exclude patterns using Gemini ({self.config.gemini_model})...")
        
        if auto_patterns := await self.gemini_client.generate_patterns(directory_tree):
            print("\nAutomatically generated exclude patterns:")
            for pattern in sorted(auto_patterns):
                print(f"  - {pattern}")
            return auto_patterns
        else:
            print("\nFailed to generate automatic exclude patterns. Using manual patterns only.")
            return set()
    
    @staticmethod
    def _display_patterns(patterns: set[str]) -> None:
        """Display final exclude patterns."""
        print("\nFinal Exclude Patterns:")
        if patterns:
            for pattern in sorted(patterns):
                print(f"  - {pattern}")
        else:
            print("  (None)")
    
    async def _execute_gitingest(
        self, 
        local_source_path: str, 
        args: argparse.Namespace,
        is_url: bool
    ) -> None:
        """Execute GitIngest with configured parameters."""
        output_file = args.output or self._get_default_output(local_source_path, is_url)
        
        print(f"\nRunning GitIngest on: {local_source_path}")
        print(f"Output file: {output_file}")
        print(f"Max file size: {args.max_size} bytes")
        
        if args.include_pattern:
            print(f"Include patterns: {', '.join(sorted(args.include_pattern))}")
        
        try:
            summary, _, _ = await ingest_async(
                source=local_source_path,
                max_file_size=args.max_size,
                include_patterns=set(args.include_pattern) if args.include_pattern else None,
                exclude_patterns=self.exclude_patterns if self.exclude_patterns else None,
                branch=args.branch if is_url else None,
                output=output_file
            )
            
            print(f"\nAnalysis complete! Output written to: {output_file}")
            print("\nSummary:")
            print(summary)
            
        except Exception as e:
            print(f"\nError running GitIngest: {str(e)}", file=sys.stderr)
            sys.exit(1)
    
    @staticmethod
    def _get_default_output(source_path: str, is_url: bool) -> str:
        """Get default output filename."""
        if is_url:
            repo_name = source_path.split('/')[-1].replace('.git', '')
            return f"digest-{repo_name}.txt"
        else:
            dir_name = Path(source_path).name
            return f"digest-{dir_name}.txt"


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Enhanced GitIngest with Gemini-powered automatic exclude pattern generation"
    )
    
    parser.add_argument("source", type=str, help="Source directory or repository URL")
    parser.add_argument("--output", "-o", help="Output file path")
    parser.add_argument("--max-size", "-s", type=int, default=10*1024*1024, 
                        help="Maximum file size to process in bytes (default: 10MB)")
    parser.add_argument("--exclude-pattern", "-e", action="append", default=[], 
                        help="Additional patterns to exclude (can be specified multiple times)")
    parser.add_argument("--include-pattern", "-i", action="append", 
                        help="Patterns to include (overrides excludes, can be specified multiple times)")
    parser.add_argument("--branch", "-b", help="Branch to clone and ingest if source is a URL")
    parser.add_argument("--api-key", help="Gemini API key (overrides GEMINI_API_KEY environment variable)")
    parser.add_argument("--gemini-model", help="Gemini model for pattern generation")
    parser.add_argument("--no-auto-exclude", action="store_true", 
                        help="Disable automatic exclude pattern generation via Gemini")
    parser.add_argument("--max-depth", type=int, default=8, 
                        help="Maximum directory traversal depth for analysis tree (default: 8)")
    parser.add_argument("--dry-run", action="store_true", 
                        help="Generate and show exclude patterns without performing ingestion")
    parser.add_argument("--show-tree", action="store_true", 
                        help="Show the directory tree used for analysis")
    parser.add_argument("--retries", type=int, default=3, 
                        help="Number of Gemini API call retries (default: 3)")
    
    return parser.parse_args()


async def main():
    """Entry point."""
    
    # Parse arguments and load config
    args = parse_arguments()
    config = load_config(args)
    
    # Create and run application
    app = SmartIngestApp(config)
    await app.run(args)


if __name__ == "__main__":
    asyncio.run(main())



================================================
File: src/core/__init__.py
================================================



================================================
File: src/core/directory_analyzer.py
================================================
"""Directory structure analyzer for Smart Ingest."""

import os
from pathlib import Path
from typing import Union


class DirectoryAnalyzer:
    """Analyzes directory structure for Smart Ingest."""
    
    def __init__(self, max_depth: int = 8):
        self.max_depth = max_depth
    
    def create_directory_tree(
        self, 
        path: Union[str, Path], 
        depth: int = 0, 
        prefix: str = "", 
        is_last: bool = True, 
        is_root: bool = True
    ) -> str:
        """Create text representation of directory structure."""
        if depth > self.max_depth:
            return prefix + "└── [Max depth reached]\n"
        
        path = Path(path)
        if not path.exists():
            return prefix + f"└── [Path not found: {path.name}]\n"
        
        base_name = path.name
        if is_root:
            result = base_name + ("/" if path.is_dir() else "") + "\n"
            connector = ""
        else:
            connector = "└── " if is_last else "├── "
            result = prefix + connector + base_name + ("/" if path.is_dir() else "") + "\n"
        
        if path.is_dir():
            new_prefix = prefix + ("    " if is_last or is_root else "│   ")
            
            try:
                items = sorted(path.iterdir(), key=lambda x: (not x.is_dir(), x.name))
            except PermissionError:
                result += new_prefix + "└── [Permission denied]\n"
                return result
            except OSError as e:
                result += new_prefix + f"└── [Error listing: {e}]\n"
                return result
            
            for i, item in enumerate(items):
                last = (i == len(items) - 1)
                result += self.create_directory_tree(
                    item,
                    depth + 1,
                    new_prefix,
                    last,
                    False
                )
        
        return result


================================================
File: src/core/gemini_client.py
================================================
"""Gemini API client for generating exclude patterns."""

import asyncio
import re
import sys
from typing import Optional

import google.generativeai as genai
from pydantic import BaseModel, Field, field_validator


class ExcludePatterns(BaseModel):
    """Model for exclude patterns."""
    
    patterns: list[str] = Field(description="List of exclude patterns as strings")
    
    @field_validator('patterns', mode='before')
    @classmethod
    def parse_and_clean_patterns(cls, v):
        """Validate and clean patterns from string or list."""
        raw_patterns = []
        
        if isinstance(v, str):
            # Remove code block markers and split comma-separated string
            cleaned_str = re.sub(r'(^```[a-zA-Z]*\s*|\s*```$)', '', v, flags=re.MULTILINE).strip()
            raw_patterns = [p.strip() for p in cleaned_str.split(',') if p.strip()]
        elif isinstance(v, list):
            raw_patterns = [str(p).strip() for p in v if str(p).strip()]
        else:
            raise ValueError("Patterns must be a string or list")
        
        # Clean each pattern
        valid_patterns = []
        for pattern in raw_patterns:
            cleaned_pattern = pattern.strip('\'"` ')
            if cleaned_pattern:
                valid_patterns.append(cleaned_pattern)
        
        return valid_patterns


SYSTEM_PROMPT = """
You are an expert assistant specialized in preparing code repositories for analysis by Large Language Models (LLMs) using tools like `gitingest`. Your sole task is to analyze a provided directory structure (given as text) and generate a **single line** string containing comma-separated patterns (glob patterns or specific paths relative to the repository root) for exclusion, **based *only* on items found within that specific structure**.

**Goal:** Identify and list patterns for files and directories *present in the input structure* that match common exclusion criteria (dependencies, compiled code, VCS, IDE config, large data/assets, lock files, environment files etc.) and are generally unnecessary or detrimental for LLM codebase understanding. Generate paths relative to the root of the provided structure.

**Exclusion Guidelines & Process:**
1.  **Analyze Input:** Carefully examine the provided directory structure, noting the exact names and locations of all files and directories.
2.  **Identify Candidates for Exclusion:** Look for items *within the input structure* that fall into common exclusion categories:
    *   Dependency directories (e.g., `node_modules/`, `venv/`, `.venv/`, `env/`, `vendor/`, `packages/`)
    *   Compiled/Generated files/directories (e.g., `__pycache__/`, `*.pyc`, `*.pyo`, `build/`, `dist/`, `target/`, `out/`, `*.class`, `*.o`, `*.obj`, `*.dll`, `*.so`)
    *   Version control system metadata (e.g., `.git/`, `.svn/`, `.hg/`)
    *   Package manager lock files (e.g., `package-lock.json`, `yarn.lock`, `poetry.lock`, `composer.lock`, `Gemfile.lock`) - Exclude if they tend to be very large or less critical for understanding core logic.
    *   IDE/Editor configuration files/directories (e.g., `.vscode/`, `.idea/`, `*.sublime-project`, `*.sublime-workspace`, `*.swp`, `*.swo`)
    *   Operating System specific files (e.g., `.DS_Store`, `Thumbs.db`)
    *   Test caches/reports (e.g., `.pytest_cache/`, `.tox/`, `coverage/`, `*.log`)
    *   Large binary assets/data (e.g., `*.zip`, `*.tar.gz`, `*.jpg`, `*.png`, `*.mp4`, `data/`) - Use judgement based on typical project structures.
    *   Environment configuration files (e.g., `.env`, `.env.*` - unless they contain crucial *example* configuration).
3.  **Generate Patterns ONLY for Present Items:** For each identified candidate *that actually exists in the input structure*:
    *   **Use Specific Relative Paths:** If the item is in a specific subdirectory (e.g., `frontend/node_modules/` if `node_modules` is inside `frontend`), use its full relative path from the root.
    *   **Use Direct Names for Root Items:** If the item is directly at the root level (e.g., `.git/`, `venv/`), use its direct name.
    *   **Use Globs for Widespread Pattern Types (if present):** If files or directories matching a *type* known to appear widely (like `__pycache__` directories or `.pyc` files) are present *anywhere* in the structure, use an appropriate glob pattern (e.g., `**/__pycache__/`, `**/*.pyc`). Base the decision to use a glob on the *nature* of the item (caches, compiled files often appear nested). Prioritize specific paths if the item appears only once or twice in specific locations.
4.  **Compile Final List:** Combine the generated patterns for all *present* excludable items into a single comma-separated string. Ensure patterns for directories end with `/`.
5.  **Strict Inclusion Rule:** **Crucially, do *not* include a pattern for any file or directory (e.g., `.vscode/`, `build/`, `node_modules/`) if it is *not explicitly listed* in the provided directory structure input.** Check the input structure carefully before adding a pattern.

**Important:** Return ONLY the comma-separated list of patterns on a single line. Do not include explanations, apologies, or code block markers (like ```).

Example input structure:
my_project/
├── .git/
├── src/
│   ├── main.py
│   └── utils.py
│   └── __pycache__/
│       └── utils.cpython-39.pyc
├── node_modules/
│   └── some_package/
├── tests/
│   └── test_main.py
├── venv/
│   └── ...
├── .env
├── package.json
└── README.md

Example output format: `.git/, node_modules/, venv/, **/__pycache__/, **/*.pyc, .env`
"""


class GeminiExcludePatternGenerator:
    """Gemini API client for generating exclude patterns."""
    
    def __init__(self, api_key: str, model_name: str, retries: int = 3):
        self.api_key = api_key
        self.model_name = model_name
        self.retries = retries
        self.model = None
        
    async def generate_patterns(self, directory_structure: str) -> Optional[set[str]]:
        """Generate exclude patterns using Gemini API."""
        if not self._configure_api():
            return None
        
        prompt = self._create_prompt(directory_structure)
        
        for attempt in range(self.retries):
            print(f"Calling Gemini API (Attempt {attempt + 1}/{self.retries})...")
            
            try:
                response = await self._call_api(prompt)
                if response:
                    return response
                
            except genai.types.generation_types.BlockedPromptException as e:
                print(f"Attempt {attempt + 1}: Gemini API call failed due to blocked prompt: {e}", file=sys.stderr)
                break
            except Exception as e:
                print(f"Attempt {attempt + 1}: Error calling Gemini API: {str(e)}", file=sys.stderr)
                if attempt < self.retries - 1:
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
        
        print("Failed to generate valid exclude patterns from Gemini API after all attempts.", file=sys.stderr)
        return None
    
    def _configure_api(self) -> bool:
        """Configure Gemini API with key."""
        try:
            genai.configure(api_key=self.api_key)
            self.model = genai.GenerativeModel(
                model_name=self.model_name,
                system_instruction=SYSTEM_PROMPT,
                generation_config={
                    "temperature": 0.1,
                    "max_output_tokens": 1024,
                }
            )
            return True
        except Exception as e:
            print(f"Error configuring Gemini API: {e}", file=sys.stderr)
            return False
    
    @staticmethod
    def _create_prompt(directory_structure: str) -> str:
        """Create prompt for Gemini API."""
        return (
            f"Analyze the following directory structure and generate a single comma-separated "
            f"line of exclude patterns based *only* on the items present. Follow the exclusion "
            f"guidelines strictly.\n\n"
            f"Directory structure:\n```\n{directory_structure}\n```\n\n"
            f"Exclude patterns:"
        )
    
    async def _call_api(self, prompt: str) -> Optional[set[str]]:
        """Call Gemini API and parse response."""
        response = self.model.generate_content(prompt)
        raw_text = response.text.strip()
        
        print(f"Gemini Raw Response:\n---\n{raw_text}\n---")
        
        try:
            parsed_patterns = ExcludePatterns(patterns=raw_text)
            if parsed_patterns.patterns:
                return set(parsed_patterns.patterns)
            else:
                print("Warning: Gemini returned an empty pattern list.")
                return None
        except Exception as e:
            print(f"Failed to parse/validate response: {e}")
            print(f"Raw response was: {raw_text}")
            return None


================================================
File: src/core/repository_handler.py
================================================
"""Repository handling for Smart Ingest."""

import asyncio
import subprocess
import tempfile
from typing import Optional, Tuple


class RepositoryHandler:
    """Handles repository cloning operations."""
    
    @staticmethod
    async def clone_repo(repo_url: str, target_dir: str, branch: Optional[str] = None) -> bool:
        """Clone a Git repository."""
        print(f"Cloning '{repo_url}'" + (f" (branch: {branch})" if branch else "") + f" into '{target_dir}'...")
        
        cmd = ["git", "clone", "--depth", "1", "--quiet"]
        if branch:
            cmd.extend(["-b", branch])
        cmd.append(repo_url)
        cmd.append(target_dir)
        
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                print("Cloning successful.")
                return True
            else:
                print(f"Error cloning repository (Return Code: {process.returncode}):", file=sys.stderr)
                print(f"Stderr: {stderr.decode().strip()}", file=sys.stderr)
                return False
        except FileNotFoundError:
            print("Error: 'git' command not found. Please ensure Git is installed and in your PATH.", file=sys.stderr)
            return False
        except Exception as e:
            print(f"An unexpected error occurred during cloning: {e}", file=sys.stderr)
            return False
    
    @staticmethod
    def create_temp_directory() -> tempfile.TemporaryDirectory:
        """Create a temporary directory for repository cloning."""
        return tempfile.TemporaryDirectory(prefix="smart_ingest_clone_")


